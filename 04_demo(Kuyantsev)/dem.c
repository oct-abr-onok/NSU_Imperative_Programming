#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>

// константная переменная (const относится к типу, а не к самой переменной)
const int GLOBAL_CONSTANT = 10;
GLOBAL_CONSTANT = 11; // попытка изменить const переменную приводит к ошибке компилятора

// глобальная переменная. Она обладает наибольшей областью видимости (scope), 
// поэтому доступ к ней есть из любой части программы (как и к GLOBAL_CONSTANT)
int global_var = 20;

// NOTE: так описываются функции: <возвращаемый_тип> <имя_функции> (<аргументы>) { <тело_функции> }
// NOTE: void - возвращаемый тип, в данном случае функция ничего не возвращает, поэтому тип - void - пустой
void scope_demo() {
	int b = 1;
	{
		printf("%d\n", b); // выведется 1
		int b = 2; // пере
		printf("%d\n", b); // выведется 2
		int c = 3;
	}
	printf("%d\n", b); // выведется 1, тк мы вернулись в предыдущую область видимости

	c = 4; // ошибка компилятора, переменная c не существует в этой области видимости
	return; // NOTE: в случае void функции return в конце можно не писать
}

void code_structure_demo(char last_literal) {
	// в C/С++ отступы не имеют значения, структура кода определяется фигурным скобками
printf("C\n");
	printf("\tallows\n");
		printf("\t\twild\n");
			printf("\t\t\tcode\n");
				printf("\t\t\t\tmargins\n");
					printf("\t\t\t\t\t%c\n", last_literal);
}

void for_cycle_and_if_demo(int n) {
	// объявление массива, содержащего массивы типа char* (т.е. объявление массива строк)
	// пока не обязательно понимать, как это работает
	const char* words[] = { "I", "can", "print", "as", "many", "blahs", "as", "you", "want" };
	const char* blah = "blah";
	const char sep = ' ';
	// структура оператора for: 
	// for(<начальная инициализация переменных>; <условие_перехода_на_следующую_итерацию>; <действие_после_каждой_итерации>) { <тело_цикла> }
	// можно инициализировать снаружи:
	/**
	int i = 0;
	for (; i < 10; ++i) {}
	*/
	// можно даже ничего не указывать: for(;;) - бесконечный цикл
	for (int i = 0; i < n; ++i) {
		// обратите внимание на структуру условного оператора
		if (i < 9) {
			printf("%s", words[i]);
			printf("%c", sep);
		}
		else {
			printf("%s", blah);
			printf("%c", sep);
		}
	}
	printf("\n");
}

int main() {
	// вызов функций
	scope_demo();

	// char - тип, обозначающий одинарный символ (на самое деле, это число, занимающее 1 байт памяти
	char argument = '!'; // обратите внимание на одинарные кавычки
	code_structure_demo(argument); // передаем аргумент в функцию

	for_cycle_and_if_demo(29);
	printf("====end-of-demo-section====\n");

	// перенаправить поток ввода из консоли в поток чтения из файла "input.txt"
	//		input.txt - название файла
	//		"r" - модификатор read - чтение из файла
	//		sdtin - стандартный поток ввода (обычно это консоль, теперь - файл)
	freopen("input.txt", "r", stdin);
	// обратите внимание, что числа в файле input.txt 
	//		могут быть записаны через пробел, а не через перенос строки - результат будет тот же
	
	// объявляем переменную а, не инициализируя ее
	// на данный момент в ней находится "мусор" вроде такого -858993460 
	int a;
	// прочитать целочисленное значение из потока ввода и положить его по адресу (знак &) переменной а
	// %d - обозначает, что мы ожидаем получить целое число
	//		Если в потоке ввода будет находиться некорректное значение, 
	//		то получим UB (undefined behaviour, неопределенное поведение)
	//		рекомендую поэкспериментировать, посмотреть, что будет
	// &a - взятие адреса переменной а. Пока примите, как данность, детальнее обсудим, 
	//		когда будем говорить про указатели
	scanf("%d", &a); // прочитали 1 из input.txt


	// перенаправить поток вывода из консоли в "запись в файл"
	// output.txt - название файла
	// "w" - модификатор write - запись в файл
	// stdout - стандартный поток вывода (обычно это консоль, теперь - файл)
	freopen("output.txt", "w", stdout);

	// вывести целочисленное значение а в поток вывода
	//		%d - то, каким образом выводить
	//		\n - символ переноса строки
	printf("%d\n", a); 

	scanf("%d", &a); // прочитали 2
	printf("%d\n", a);

	scanf("%d", &a); // прочитали 10
	printf("%d\n", a);
	return 0;
}